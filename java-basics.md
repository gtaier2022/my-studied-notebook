<h5>1.java语言的特性

开源，免费，面向对象，跨平台

java不支持多继承，C++支持

C++有指针的概念，Java屏蔽了指针的概念

Java是由C++实现的

Java的生态很好

面向对象，更符合人的思维模式，其复用性拓展性，可移植性也大大提高。

支持多线程

健壮性，有自动回收垃圾的机制



<h5>2.java的加载与执行

.java的源程序通过编译成字节码文件.class文件，再通过类加载器加载到虚拟机，由java虚拟机将.class文件编译成二进制文件与操作系统打交道，再由操作系统执行二进制与底层硬件系统交互。



<h5>3.classpath

如果没有指定classpath的话，那么它会默认为当前位置为classpath

 

<h5>4.BigDeciaml详解

为了避免极大丢失，可以使用BigDecimal来进行浮点数的运算

浮点数与浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断

使用BigDeciaml时，应该使用BigDecimal(String val)构造方法或者BigDecimal.valueOf(double val) 的静态方法来构造



<h5>5.字符串常量和字符型常量的区别

字符常量是由单引号引起来的一个字符串，相当于一个整型值，可以参加运算表达式，只占2个字节

字符串常量是由双引号引起的一个或者多个字符，字符串常量通常是代表宇哥字符串在内存中存储的位置。占若干个字节

<h5>6.静态方法为什么不能调用非静态成员

静态方法属于类，在加载类的时候就会分配空间。可以通过类名直接访问，而非静态是属于实列对象的，通常通过类的实列对象去访问，在java中类的非静态成员在不纯在的时候静态成员静态方法就已经存在了，此时调用内存中还不处在的非静态成员遍历，属于非法操作(李靖邀请岳飞当偏将)

在调用方法的时候有何不同

调用的时候静态方法通常是类名.方法名的方式，也可以采用对象名。方法名在调用实列方法的时候只能采用对象名.方法名

静态方法只能访问金泰成员，实列方法即能访问成员变成，也能访问静态变量



<h5>可变参数

一个方法可以接收0个或者多个同样类型的参数

语法:method(String ...  args)

可变参数只能作为函数的最后一个参数

遇到方法重载会优先匹配固定参数的方法。



<h5>基本的数据类型

8种基本的数据类型

6钟数字型

4钟数字类型:byte,short int long

浮点型:float,double

一种字符型char

一种boolean

在long数据类型后面一定要加l，否则将作为整数去解析。

成员变量不赋值就是null，而基本类型有默认值且不是null。

包装类可以用为泛型，基本类型不可以

基本类型的局部变量存放在Java虚拟机栈中的局部变量表中，基本数据类型的成员变量放在Java虚拟机中的堆中，包装类型属于镀锡类型，我们知道几乎所有的对象占用实列都存在于堆中。

相比较于对象类型，基本数据类型占用的内存空间非常小





<h5>自动拆箱和装箱

装箱:将基本数据类用他们对应引用类型包装起来

拆箱:将包装类型转换为基本数据类型

```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

频繁的装箱和拆箱操作将严重影响系统的性能。



<h5>面向对象和面向过程的区别

面向过程是把解决问题的过程拆解为一个个方法，通过一个个方法的执行解决问题

面向对象会先抽出对象，然后用对象执行方法的方式解决问题

面向的对象的程序一般更易维护，易复用，易拓展。



<h5>成员变量于局部变量的区别

语法上:成员变量是属于类的，而局部变量是在代码块或者方法中定义的变量或是方法的参数，成员变量可以被public，private，static等修饰符修饰，而局部变量是不能被static修饰，当时成员变量和局部变量都能被final修饰。

存储方式，成员变量是存储在堆内存中，局部变量是存储在栈内存中，

生存时间，成员变量是对象一部分，它随着对象的存在而存在，局部变量是随着方法的调用而自动生成，随着方法的接收而消亡。

默认成员如果没有被赋值，则会以类型的默认值而赋值，而局部变量不会被赋值。



<h5>对象的相等和引用相等的区别

对象的相等一般比较的是内存中存放的内容是否相等。

引用相等一般是他们执行的内存订单是否相等。



<h5>类的构造方法有什么作用

构造方法是一个特殊的方法，它主要完成对象的初始化工作。

