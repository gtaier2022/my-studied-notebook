<h5>1.java语言的特性

开源，免费，面向对象，跨平台

java不支持多继承，C++支持

C++有指针的概念，Java屏蔽了指针的概念

Java是由C++实现的

Java的生态很好

面向对象，更符合人的思维模式，其复用性拓展性，可移植性也大大提高。

支持多线程

健壮性，有自动回收垃圾的机制



<h5>2.java的加载与执行

.java的源程序通过编译成字节码文件.class文件，再通过类加载器加载到虚拟机，由java虚拟机将.class文件编译成二进制文件与操作系统打交道，再由操作系统执行二进制与底层硬件系统交互。



<h5>3.classpath

如果没有指定classpath的话，那么它会默认为当前位置为classpath

 

<h5>4.BigDeciaml详解

为了避免极大丢失，可以使用BigDecimal来进行浮点数的运算

浮点数与浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断

使用BigDeciaml时，应该使用BigDecimal(String val)构造方法或者BigDecimal.valueOf(double val) 的静态方法来构造



<h5>5.字符串常量和字符型常量的区别

字符常量是由单引号引起来的一个字符串，相当于一个整型值，可以参加运算表达式，只占2个字节

字符串常量是由双引号引起的一个或者多个字符，字符串常量通常是代表宇哥字符串在内存中存储的位置。占若干个字节

<h5>6.静态方法为什么不能调用非静态成员

静态方法属于类，在加载类的时候就会分配空间。可以通过类名直接访问，而非静态是属于实列对象的，通常通过类的实列对象去访问，在java中类的非静态成员在不纯在的时候静态成员静态方法就已经存在了，此时调用内存中还不处在的非静态成员遍历，属于非法操作(李靖邀请岳飞当偏将)

在调用方法的时候有何不同

调用的时候静态方法通常是类名.方法名的方式，也可以采用对象名。方法名在调用实列方法的时候只能采用对象名.方法名

静态方法只能访问金泰成员，实列方法即能访问成员变成，也能访问静态变量



<h5>可变参数

一个方法可以接收0个或者多个同样类型的参数

语法:method(String ...  args)

可变参数只能作为函数的最后一个参数

遇到方法重载会优先匹配固定参数的方法。



<h5>基本的数据类型

8种基本的数据类型

6钟数字型

4钟数字类型:byte,short int long

浮点型:float,double

一种字符型char

一种boolean

在long数据类型后面一定要加l，否则将作为整数去解析。

成员变量不赋值就是null，而基本类型有默认值且不是null。

包装类可以用为泛型，基本类型不可以

基本类型的局部变量存放在Java虚拟机栈中的局部变量表中，基本数据类型的成员变量放在Java虚拟机中的堆中，包装类型属于镀锡类型，我们知道几乎所有的对象占用实列都存在于堆中。

相比较于对象类型，基本数据类型占用的内存空间非常小





<h5>自动拆箱和装箱

装箱:将基本数据类用他们对应引用类型包装起来

拆箱:将包装类型转换为基本数据类型

```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

频繁的装箱和拆箱操作将严重影响系统的性能。



<h5>面向对象和面向过程的区别

面向过程是把解决问题的过程拆解为一个个方法，通过一个个方法的执行解决问题

面向对象会先抽出对象，然后用对象执行方法的方式解决问题

面向的对象的程序一般更易维护，易复用，易拓展。



<h5>成员变量于局部变量的区别

语法上:成员变量是属于类的，而局部变量是在代码块或者方法中定义的变量或是方法的参数，成员变量可以被public，private，static等修饰符修饰，而局部变量是不能被static修饰，当时成员变量和局部变量都能被final修饰。

存储方式，成员变量是存储在堆内存中，局部变量是存储在栈内存中，

生存时间，成员变量是对象一部分，它随着对象的存在而存在，局部变量是随着方法的调用而自动生成，随着方法的接收而消亡。

默认成员如果没有被赋值，则会以类型的默认值而赋值，而局部变量不会被赋值。



<h5>对象的相等和引用相等的区别

对象的相等一般比较的是内存中存放的内容是否相等。

引用相等一般是他们执行的内存订单是否相等。



<h5>类的构造方法有什么作用
构造方法是一个特殊的方法，它主要完成对象的初始化工作。





<h5>如果一个类没有声明构造方法，该程序能正确执行吗?

如果一个类没有声明构造方法，也可以执行，因为回有一个无参构造。如果一个类添加了一个有参构造，java就不会再添加默认的无参构造，如果重载了有参构造方法，记得要把无参构造方法写出来。



<h5>构造方法有哪些特点？是否可被override

无参构造方法特点如下

名字与类名相同，没有返回值，当时不能用void声明构造函数。生成类的对象时自动执行，无需调用。

构造方法不能被override重写，但是可以被overload(重载)，所以你可以看到一个类有多个构造函数的情况。



<h5>面向对象的三大特征

封装，继承，多态

封装是把一个对象的状态信息隐藏再对象内部，不允许外部对象直接访问到内部的信息。但是可以提供一些可以被外界访问的方法来操作属性。

继承：不同类型的对象，经常会有共同的特征，继承是再已存在内的定义作为基础创建新的类。新类可以添加的新的数据或功能，也可以用父类的功能。可以提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。

父类的私有方法和私有属性是无法访问的。

子类可以对父类进行拓展。

子类可以用自己的方式实现父类的方法。

多态：

表示一个对象具有多个形态，具体表现为父类引用指向子类的实例。

继承/实现 重写方法，父类引用指向子类对象。

对象类型和引用类型之间具有继承或者是实现的关系。

引用类型变量发出的方法调用的到底是哪一个类中的方法，必须再程序运行期间才能确定。

多态不能调用只在子类存在但再父类不存在的方法

如果子类重写了父类的方法真正执行的子类覆盖的方法，如果子类没有覆盖父类的方法，执行的父类的方法。



<h5>接口和抽象类的区别有什么共同点和区别。

共同点:

都不能被实列话，

都可以包含抽象方法

都可以由默认的实现方法。

区别：

接口主要对类的行为进行约束。抽象类强调的是代码的复用。

一个类只能单继承，可以多实现。

接口中的成员变量只能是public static final 类型的，不能修改且必须由初始值。而抽象类的成员变量可以再子类中被抽象赋值，是default修饰。





<h5>深拷贝和浅拷贝

浅拷贝:会再堆上创建一个新的对象。不够，如果员对象的内部的属性是引用型的话，浅拷贝会直接复制内部对象的引用地址，也就是说，拷贝的对象和员对象共用一个内部对象。

深拷贝:深拷贝会完全复制整个对象，包括对象所包含的内部对象。



<h5>Java 常见类

Object

是所有类的父类，它提供11个方法

```java
/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * naitive 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }
```



<h5>== 和 equals()的区别

==对于基本类型和引用类型的作用是不同的；

对于基本的数据类型来说，==比较的是值，

对于引用数据类型来说，==比较的是对象的内存地址。



<h5>hashcode（）

hashcode()获取散列码，这个散列码的作用是确认该对象再hash表的索引位置。该方法通常就将该对象的内存地址转换为int类型返回。

hash表存储的是键值对kv，它的特点是能够工具键快速索引出对应的值。

```java
当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。
```

hashcode 能够减少equal是方法的次数

地址值再转换为hashcode的过程中会产生hash碰撞，即hashcode一样，而对象不一样的情况。

两个相同对象的hashcode必须一致，如果equals方法判断两个对象是相等的hashcode值也必须相等。



<h5>String、StringBuffer、StringBuilder 的区别？

`String` 是不可变的 每一次后面加一个字符串都new String对象

StringBuffer、StringBuilder提供了修改字符串长度的方法。

线程安全性

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。

StringBuffer再方法上加入了同步锁，所以是线程安全的。

StringBuilder每一加同步锁所以是非线程安全的。

性能:

相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

对于三种使用情况的总结

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer

intern 方法有什么作用?

String.intern()` 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：



<h5>try-catch-finally如何使用

try块:用于捕获异常，其后可跟多个或者0个catch块，每一catch块，则必须跟一个finally块。

catch块:用于处理try捕获的异常。

finally块:无论是否捕获异常，finally块里面的语句都会执行。当try块或者catch块中遇到return语句时，finally语句块将再方法返回之前被执行。

不要在finally语句块中使用return，当try语句中和finally语句中都有return语句时，try中的return会被忽略，这是因为try语句中的retrun放回值先被存在本地变量中，当执行到finally语句中的return之后，本地变量的值就变为了finally语句中的return返回值

finally的代码块一定会执行吗？

不一定，比如说finally之前虚拟机终止运行的话，finally代码就不会执行。(程序所在的线程死亡关闭cpu)

不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常我们都需要手动new一个异常对象抛出，

抛出的消息一定要有意义，抛出的异常应该更具体。

使用日志打印了异常之后就不要抛出异常了。





<h5> 泛型：

泛型参数增强代码的稳定性以及可读性。

泛型的使用方法：

泛型类：泛型接口：泛型方法



项目中那些用到了泛型。

自定义接口通用的返回结果用到了泛型

定义Excel处理类ExcelUtils<T>用于动态指定Excel导出的数据类型。

构建集合工具类()



<h5>反射

开源通过它获取任意的类的所有属性和方法和调用这些属性和方法的机制。

反射的应用场景

大多数的框架都是基于放射的原理

```java
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
    }
}

```

注解也使用了反射。

注解的解析方法编译(@Overide)被扫面和运行(@Component)其通过反射处理



<h5>序列化(Serializable)

序列化:将数据结构转换为二进制流字节流的过程。

反序列化:将在序列化过程钟发所生成二进制字节流转换成数结够或者是对象的过程。

对于不想进行序列化的变量，使用transient关键字装饰。

不能修饰类和方法。

static不属于对象，所以无论有没有transient关键字修饰，均不会被序列化。



<h5>Java中的IO流

InputStream/Reader

OutputStream/Writer

既然有了字节流,为什么还要有字符流?

字符流方便我们堆字符进行流操作（因为可能不知道字符的编码格式）。





<h5>几个关键字

final: 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量

static：

j修饰成员变量和和成员方法。

​	静态代码块：静态代码块定义在类方法之外，静态diamond块在非静态代码块之前执行{静态代码块->非静态代码块->构造方法}。无论该类创建多少个对象，静态代码块只执行一次。

静态导包:用来导入类中的静态资源。可以直接使用该类的成员变量和成员方法。

静态内部类:它的创建不需要依赖外围内的创建，不能使用任何外围类的非staic的变量和方法。

this:指向当前的实列

super:用于从子类访问父类的变量和方法。



<h5>为什么 Java 中只有值传递

如果传递的是基本的类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。

如果参数是引用类型的话，传递的就是实参所用对象在堆中地址值的拷贝。



<h5>代理模式

  我们使用代理对象来代替真实对象的访问，这样我们在不修改原对象的前提下，提供额外的功能操作，扩展目标对象的功能。

代理模式的主要作用是扩展目标的功能，比如说在目标对象的某一个方法执行执行前后增加一些自定义操作。

静态代理和动态代理

静态代理:目标对象的每一个方法都是都得完成的；

​				静态代理在编译时将接口实现类，代理类都变成一个个实际的class文件。

静态代理实现步骤:

定义一个接口及其实现类；

创建一个代理类同样实现这个接口/

将目标对象注入进代理类，然后在代理类的对应订单调用目标类中的对应的方法。这样就可以通过代理类屏蔽掉目标对象的访问。并且可以在方法前后做一些增强。

